#ifndef IPCPRIMS_H
#define IPCPRIMS_H

/* Generated with cbindgen:0.29.2 */

/* This file is auto-generated by cbindgen. Do not edit manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

#define IPC_CHANNEL_CONTROL 0

#define IPC_CHANNEL_COMMAND 1

#define IPC_CHANNEL_DATA 2

#define IPC_CHANNEL_TELEMETRY 3

#define IPC_CHANNEL_ERROR 4

enum IpcResult {
    IPC_RESULT_OK = 0,
    IPC_RESULT_INVALID_ARGUMENT = 1,
    IPC_RESULT_TRANSPORT_ERROR = 2,
    IPC_RESULT_FRAME_ERROR = 3,
    IPC_RESULT_HANDSHAKE_FAILED = 4,
    IPC_RESULT_DISCONNECTED = 5,
    IPC_RESULT_UNSUPPORTED_CHANNEL = 6,
    IPC_RESULT_BUFFER_FULL = 7,
    IPC_RESULT_TIMEOUT = 8,
    IPC_RESULT_SHUTDOWN_FAILED = 9,
    IPC_RESULT_SCHEMA_ERROR = 10,
    IPC_RESULT_INTERNAL = 99,
};
typedef int32_t IpcResult;

typedef struct IpcFrame {
    uint16_t channel;
    uint8_t *data;
    uintptr_t len;
} IpcFrame;

typedef void *IpcListenerHandle;

typedef void *IpcPeerHandle;

typedef void *IpcSchemaRegistryHandle;

























IpcResult ipc_init(void);

void ipc_cleanup(void);

const char *ipc_last_error(void);

/**
 * Free payload memory held by an [`IpcFrame`] populated by recv APIs.
 *
 * # Safety
 * `frame` must be either null or a valid pointer to an `IpcFrame` created by caller code.
 * If `frame->data` is non-null, it must have originated from this library.
 */
void ipc_frame_free(struct IpcFrame *frame);

/**
 * Bind a peer listener at `path`.
 *
 * # Safety
 * `path` must be a non-null pointer to a valid UTF-8, NUL-terminated C string.
 */
IpcListenerHandle ipc_listener_bind(const char *path);

/**
 * Accept an incoming peer connection.
 *
 * # Safety
 * `listener` must be a valid listener handle returned by `ipc_listener_bind`.
 */
IpcPeerHandle ipc_listener_accept(IpcListenerHandle listener);

/**
 * Free a listener handle.
 *
 * # Safety
 * `listener` must be null or a handle previously returned by `ipc_listener_bind`.
 */
void ipc_listener_free(IpcListenerHandle listener);

/**
 * Connect to a listener path with an optional channel list.
 *
 * # Safety
 * `path` must be a non-null UTF-8 C string. If `num_channels > 0`, `channels` must be non-null
 * and point to `num_channels` readable `uint16_t` values.
 */
IpcPeerHandle ipc_connect(const char *path, const uint16_t *channels, uintptr_t num_channels);

/**
 * Send payload bytes on a negotiated channel.
 *
 * # Safety
 * `peer` must be a valid peer handle. If `len > 0`, `data` must be non-null and readable for
 * `len` bytes.
 */
IpcResult ipc_peer_send(IpcPeerHandle peer, uint16_t channel, const uint8_t *data, uintptr_t len);

/**
 * Receive the next non-control frame.
 *
 * # Safety
 * `peer` must be a valid peer handle and `out_frame` must be a valid writable pointer.
 * If `out_frame->data` already contains a prior payload from this library, it is freed first.
 */
IpcResult ipc_peer_recv(IpcPeerHandle peer, struct IpcFrame *out_frame);

/**
 * Receive the next frame on a specific channel.
 *
 * # Safety
 * `peer` must be a valid peer handle and `out_frame` must be a valid writable pointer.
 * If `out_frame->data` already contains a prior payload from this library, it is freed first.
 */
IpcResult ipc_peer_recv_on(IpcPeerHandle peer, uint16_t channel, struct IpcFrame *out_frame);

/**
 * Send a control ping and return round-trip time in nanoseconds.
 *
 * # Safety
 * `peer` must be a valid peer handle and `out_rtt_ns` must be a non-null writable pointer.
 */
IpcResult ipc_peer_ping(IpcPeerHandle peer, uint64_t *out_rtt_ns);

/**
 * Gracefully shutdown a peer connection.
 *
 * # Safety
 * `peer` must be a valid peer handle.
 */
IpcResult ipc_peer_shutdown(IpcPeerHandle peer);

/**
 * Free a peer handle.
 *
 * # Safety
 * `peer` must be null or a handle returned by `ipc_connect` or `ipc_listener_accept`.
 */
void ipc_peer_free(IpcPeerHandle peer);

/**
 * Load schema registry from a directory.
 *
 * # Safety
 * `path` must be a non-null pointer to a valid UTF-8, NUL-terminated C string.
 */
IpcSchemaRegistryHandle ipc_schema_registry_from_directory(const char *path);

/**
 * Validate payload bytes for a channel against the loaded schema.
 *
 * # Safety
 * `registry` must be a valid handle. If `len > 0`, `data` must be non-null and readable.
 */
IpcResult ipc_schema_registry_validate(IpcSchemaRegistryHandle registry,
                                       uint16_t channel,
                                       const uint8_t *data,
                                       uintptr_t len);

/**
 * Free a schema registry handle.
 *
 * # Safety
 * `registry` must be null or a handle returned by `ipc_schema_registry_from_directory`.
 */
void ipc_schema_registry_free(IpcSchemaRegistryHandle registry);

#endif  /* IPCPRIMS_H */
